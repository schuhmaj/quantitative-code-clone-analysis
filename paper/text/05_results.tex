% !TeX spellcheck = en_US

\section{Results}
\label{sec:results}

This section now provides the results and a brief description of the previously presented study design. 

\begin{figure}[tbh!]
	\centering
	\includegraphics[width=0.85\linewidth]{figures/results/scatter_clone_coverage_loc_m}
	\caption{Clone Coverage depending on projects' \ac{sloc} with trend lines plotted}
	\label{fig:overview_results}
\end{figure}

\begin{figure}[tbh!]
	\centering
	\includegraphics[width=0.85\linewidth]{figures/results/number}
	\caption{Complementary cumulative distribution function for the number of projects given a certain \ac{sloc} threshold}
	\label{fig:overview_numbers}
\end{figure}

A first overview is given in \autoref{fig:overview_results}, which plots the clone coverage in dependence to the project size, i.e. the \acl{sloc}, for all analyzed projects. Further, the plot contains a trend line for each programming language in order to enable better comparability. These trend lines depict the mean value of clone coverage for every programming language until around $10^6$ of \ac{sloc} pretty close. Also, they clearly show that bigger projects tend to have a greater clone coverage.
Nevertheless, the data far beyond $10^6$ \acl{sloc} should be taken with caution for some programming languages since not enough data could be collected for the bigger size regimes. 
\autoref{fig:overview_numbers} portrays this situation with the tick $10^6$ \ac{sloc} being marked since before $10^6$, we have at least 100 projects for every programming language, whereas languages like \texttt{Kotlin} and \texttt{Rust} only have small amounts of samples for e.g. more than $10^6$ \ac{sloc}.

\autoref{fig:histo_all} extends the information of \autoref{fig:overview_results} by giving the exact distributions, as well as, the mean and standard deviation values for every programming language. If one compare the mean clone coverage values for every programming language with one another, modern programming languages like \texttt{Rust}, \texttt{Kotlin} and \texttt{Go} seem to perform better than their older counterparts \texttt{C/C++} and \texttt{Java}. Further, \texttt{C} and \texttt{C++} appear to have only little difference in terms of clone coverage distributions. \texttt{Python} performs overall best.

Supplementary to the total distribution, \autoref{fig:histo_million} narrows this down to just presenting projects with more than one million \acl{sloc}. As previously mentioned, one million \ac{sloc} is the range where still enough data is present for some adequate evidence. These projects are also more expressive due to their sheer size. The general observations still holds, with one exception: \texttt{Go} performs far worse. Further as already perceived in \autoref{fig:overview_results}, all languages have greater mean values overall.

Since the pure observation is not sufficient for answering the \aclp{rq} precisely, the two-sample Welch's $t$-test is used to determine if the differences in clone coverage mean values are significant. This test assumes that the sample mean values are distributed normally which holds due to the Central Limit Theorem \cite{shafer2022introductory}. In contrast to Student's $t$-test it allows unequal variances, which exist here. \autoref{tab:stat_test} shows the calculated $t$ statistics and $p$ values for four scenarios. With a level of significance of $\alpha = 5\%$, \texttt{C} and \texttt{C/C++} mean values are not significantly different since $p > \alpha$ leads to acceptance of $H_0$: equal means. This circumstance answers \refrq{question:compare_c_cpp} with no.
A Kolmogorovâ€“Smirnov test with an $\alpha=5\%$ comparing the \texttt{C} and \texttt{C/C++} distributions actually lead to the acceptance of the null hypothesis that both distributions are equal. This means, if one would not know which distribution belongs to which language, one could not even determine it.

The next two rows answer \refrq{question:compare_rust_c} and \refrq{question:compare_kotlin_java}. In both cases are the mean values significantly different, which leads to rejection of $H_0$ and acceptance of $H_1$: \texttt{C/C++} and \texttt{Java} have on average a significantly higher mean clone coverage than respectively \texttt{Rust} and \texttt{Kotlin}. So both questions can be answered with "yes".
Lastly, \texttt{C/C++} and \texttt{Java} are compared with the result of no significant difference in the mean values for $\alpha = 5\%$.

\begin{table}[tbh!]
	\centering
	\begin{tabular}{|cc||c|c||c|c|}
		\hline
		\multicolumn{2}{|c||}{Samples} & \multicolumn{2}{c||}{$SLOC \geq 0$} & \multicolumn{2}{c|}{$SLOC \geq 1000000$}  \\
		\multicolumn{2}{|c||}{from} & \multicolumn{1}{c}{$t$ statistic} & \multicolumn{1}{c||}{$p$ value} & \multicolumn{1}{c}{$t$ statistic} & $p$ value \\
		\hline
		\hline
		C & C/C++ & $-1.021$ & $0.846$ & $1.105$ & $0.135$ \\
		\hline
		\hline
		C/C++ & Rust & $9.936$ & $1.517 \cdot 10^{-22}$ & $6.612$ & $3.957 \cdot 10^{-11}$ \\
		\hline
		Java & Kotlin & $5.946$ & $2.264 \cdot 10^{-9}$ & $2.500$ & $0.006$ \\
		\hline
		\hline
		C/C++ & Java & $0.720$ & $0.236$ & $0.643$ & $0.260$ \\
		\hline
	\end{tabular}
	\caption{Results of Welch's $t$-test with $H_0$ being that the means of the two underlying distributions have equal means and $H_1$ that the mean of the first distribution is greater than the mean of the second sample.}
	\label{tab:stat_test}
\end{table}

Overall, \autoref{fig:matrix_comp} lists all possible pairings of examined programming languages and depicts which one performs significantly better than its companion. \autoref{fig:matrix_comp} complements \refrq{question:comparing_age} by giving answer to the top-level \ac{rq} and gives a clear answer for \refrq{question:clone_coverage_lowest}.
\autoref{fig:matrix_comp} clearly depicts that \texttt{Python} always performs better in terms of mean code clone coverage than any other programming language independent from the applied filter for \aclp{sloc}. So  \refrq{question:clone_coverage_lowest}'s answer is \texttt{Python}, which was first released in 1991\footnote{\url{https://en.wikipedia.org/wiki/Python_(programming_language)}, lasted accessed: 13.07.2022}.
This fact also implies that newer generation programming languages do not necessarily have lower code clone coverage than older programming languages. The fact that \texttt{Go} behaves in terms of mean code clone coverage similarly to \texttt{C/C++} and \texttt{Java} supports this circumstance, even if it first appeared in 2009\footnote{\url{https://en.wikipedia.org/wiki/Go_(programming_language)}, last accessed: 13.07.2022}.

However, fully answering \refrq{question:comparing_age} with no, would be short-sighted, as the direct competitors \texttt{Rust} and \texttt{Kotlin} perform better than \texttt{C/C++} and \texttt{Java}. These discoveries are broadly discussed in \autoref{sec:discussion}.

\begin{figure}[tbh!]
	\centering
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/comparison/comparison_all_5percent}
		\caption{with minimal $SLOC > 0$}
		\label{fig:matrix_comp_all}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/comparison/comparison_million_5percent}
		\caption{with minimal $SLOC \geq 10^{6}$}
		\label{fig:matrix_comp_million}
	\end{subfigure}
	\caption{Matrix comparison which programming languages has significantly lower mean clone coverage (green), equal mean clone coverage (yellow) and higher mean clone coverage (red) with an $\alpha=5\%$. The comparison is performed by using Welch's $t$-tests. The matrix is read in the following fashion: "Sample 1 performs better/neutral/worse than Sample 2".}
	\label{fig:matrix_comp}
\end{figure}

\begin{figure}[p]
	\centering
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/c/histogram_all}
		\caption{for pure \texttt{C}}
		\label{fig:histo_all_c}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/cpp/histogram_all}
		\caption{for \texttt{C/C++}}
		\label{fig:histo_all_cpp}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/rust/histogram_all}
		\caption{for \texttt{Rust}}
		\label{fig:histo_all_rust}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/python/histogram_all}
		\caption{for \texttt{Python}}
		\label{fig:histo_all_python}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/java/histogram_all}
		\caption{for \texttt{Java}}
		\label{fig:histo_all_java}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/kotlin/histogram_all}
		\caption{for \texttt{Kotlin}}
		\label{fig:histo_all_kotlin}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/go/histogram_all}
		\caption{for \texttt{Go}}
		\label{fig:histo_all_go}
	\end{subfigure}
	\caption{Histograms of the clone coverage distribution for the seven examined programming languages containing all project. Each plot contains the mean value and the standard deviation.}
	\label{fig:histo_all}
\end{figure}


\begin{figure}[p]
	\centering
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/c/histogram_million}
		\caption{for pure \texttt{C}}
		\label{fig:histo_million_c}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/cpp/histogram_million}
		\caption{for \texttt{C/C++}}
		\label{fig:histo_million_cpp}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/rust/histogram_million}
		\caption{for \texttt{Rust}}
		\label{fig:histo_million_rust}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/python/histogram_million}
		\caption{for \texttt{Python}}
		\label{fig:histo_million_python}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/java/histogram_million}
		\caption{for \texttt{Java}}
		\label{fig:histo_million_java}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/kotlin/histogram_million}
		\caption{for \texttt{Kotlin}}
		\label{fig:histo_million_kotlin}
	\end{subfigure}
	\begin{subfigure}[t]{0.49\textwidth}
		\includegraphics[width=\textwidth]{figures/results/go/histogram_million}
		\caption{for \texttt{Go}}
		\label{fig:histo_million_go}
	\end{subfigure}
	\caption{Histograms of the clone coverage distribution for the seven examined programming languages containing only projects with at least one million \ac{sloc}. Each plot contains the mean value and the standard deviation.}
	\label{fig:histo_million}
\end{figure}