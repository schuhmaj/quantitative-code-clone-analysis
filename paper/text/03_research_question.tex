% !TeX spellcheck = en_US

\section{Research Questions}
\label{sec:research_question}

\autoref{sec:reasons_for_code_clones} presented reasons how the choice of programming language can affect the number of code clones in a software project. \autoref{sec:similiar_analyses} showed recent findings regarding a comparison between build systems and an actual fine-granular examination of \texttt{Java} and \texttt{Scala}. This paper builds on top of those results and examines the correlation of clone coverage in different programming languages on a quantitatively large scale. Hence, the following \ac{rq} are discussed on the remaining pages:

\begin{enumerate}
	\item Which programming language has the lowest (mean) clone coverage? \label{question:clone_coverage_lowest}
	\item Do modern programming languages have lower (mean) clone coverage than older ones? \label{question:comparing_age}
	\begin{enumerate}
		\item Does pure \texttt{C} generally have a higher clone coverage than \texttt{C/C++}? \label{question:compare_c_cpp}
		\item Does \texttt{Rust} improve \texttt{C/C++} in terms of clone coverage? \label{question:compare_rust_c}
		\item Does \texttt{Kotlin} improve \texttt{Java} in terms of clone coverage? \label{question:compare_kotlin_java}
	\end{enumerate}
\end{enumerate}

\refrq{question:clone_coverage_lowest} searches for the most promising programming language in terms of code clone coverage and flows into the generalization that modern programming languages are generally better than ancient languages.
\refrq{question:compare_c_cpp} is generally of interest because \texttt{C++} is a super-set of \texttt{C}. \refrq{question:compare_rust_c}  and \refrq{question:compare_kotlin_java} are two shapings of the same question if a new programming language that aims at improving the flaws of previous generation languages is also capable of improving code quality properties like clone coverage.

It is essential to note that no question explores the "Why?" since the following case study relies on quantitatively measuring code clone coverage in thousands of projects by examining the source code, but not their concrete software engineering processes, i.e., principles. Instead, \autoref{sec:results} will show particular tendencies for specific programming languages, which are then discussed based on the formulated research questions in \autoref{sec:discussion}.
