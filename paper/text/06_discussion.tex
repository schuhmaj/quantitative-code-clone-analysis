% !TeX spellcheck = en_US

\section{Discussion}
\label{sec:discussion}

\autoref{sec:results} has shown that the in \autoref{sec:study_design} presented approach for quantitatively measuring clone coverage in different programming languages is capable to answer some of the asked \aclp{rq}. This section is going to discuss and explain the observed results, but will also evaluate the used approach.

\subsection{Implications of the result}

%Can we infer that a simpler, less verbose, more modern programming language always leads to less code clones?

Generally, the extracted data does not imply that a certain programming language like e.g. \texttt{Python}, which performed best, should be used for every project. However, the results show that certain languages, \texttt{Python}, \texttt{Kotlin} and \texttt{Rust}, performed significantly better than \texttt{C/C++}, \texttt{Java}, and therefore, seem to have advantages towards the other ones.
One reason for fewer clones could be a less-verbose, simpler programming language design as discussed in \autoref{sec:similiar_analyses}, yet this argument can be discarded, since \texttt{Go} performs for projects bigger than $10^6$ \ac{sloc} similar to \texttt{Java} and \texttt{C/C++}. Although \texttt{Go} has the smallest set of keywords - implying simplicity, as depicted in \autoref{tab:keyword_number}.

\begin{table}[tbh!]
	\centering
	\begin{tabular}{|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{1.5cm}|}
		\hline
		C/C++ 17 & Kotlin 1.4 & Rust 1.46 & Java 14 & C18 & Python 3.8 & Go 1.15 \\
		\hline
		84 & 79 & 53 & 51 & 44 & 35 & 25 \\
		\hline
	\end{tabular}
	\caption{Number of keywords for each examined programming language \cite{meyer2022keywords}}
	\label{tab:keyword_number}
\end{table}

Further, \autoref{sec:similiar_analyses} already introduced build systems as crucial for projects success. Here might be another reason located. A simple to use package manager makes importing existing solutions much easier, thereby prevents "Reinventing the wheel" a.k.a copying existing solutions. \texttt{Rust} and \texttt{Python} both come with package managers \texttt{cargo} and \texttt{pip} making the use of existing solutions much easier. In comparison, \texttt{C/C++} and \texttt{Java} rely on build systems like \texttt{CMake} and \texttt{Maven}, usually with a high learning curve. For example, to include a simple package/ library in \texttt{Python} one just needs to install and import it, whereas in \texttt{CMake} far more effort would be needed.

Lastly, one one does not forget that e.g. \texttt{Kotlin} and \texttt{Rust} improve \texttt{Java} and \texttt{C/C++}, respectively introducing null-safety and ownership. Thus these improvements avoid redundant often repeated runtime-checks like mentioned in \autoref{sec:reasons_for_code_clones} (reusing certain code structures).

In spite of these reasons, the difference of mean clone coverage do not necessarily indicate that the programming language has flaws.
Older projects often has a greater (legacy) code base, which already can contain clones, and makes it easy to just copy and paste from there. However, projects in \texttt{Rust}, \texttt{Kotlin} and \texttt{Go} are not yet as old as projects in \texttt{C/C++} or \texttt{Java}. Thereby, the newer programming languages do have some "time" advantage towards the older ones with projects having less developer-changes and less legacy code.

In conclusion, we can finalize with the strong empirical suspect that \texttt{Python}, \texttt{Kotlin} and \texttt{Rust} are better designed in preventing code cloning than \texttt{C/C++}, \texttt{Java} and \texttt{Go}, especially for bigger projects with greater code bases.

 
\subsection{Threads to validity}

As the section above finalizes the conclusion of this work, it is required to also include potential distortions.

First of, the \textit{awesome lists} are different in size and contain different content for every programming language. They are created by numerous contributor, however we little information why something is on the list. So it is likely, that each list contains a certain bias. Additionally, the lists can also contain repositories containing only code snippets and similar utility. The expressive analysis for more than $10^6$ \ac{sloc} should ensure that such projects are excluded, but a certain residual risk remains.

Directly related to this, the programming projects originate all from \textit{GitHub} and are publicly available. This circumstance is definitely a bias, since our study is not able to cover proprietary code nor big projects hosted on a different source.

The biggest bias could be the evolution of programming languages. Writing modern \texttt{C++20} follows different guidelines than writing \texttt{C++98}, this hold analogous for \texttt{Java} and \texttt{Python}. However, the study does not include when the projects was initially written and if it was refactored.

Lastly, $5224$ projects of only seven different programming languages were analyzed, which is of course only a tiny fraction at all.

\subsection{Future Work}

Directly related to the previous lessons of this section, future work could improve the solution by extending the scale of investigated projects and the concrete source. For example, an discarded approach for this work was the inclusion of all projects from \textit{GitHub} with a certain amount of stars. The inclusion of projects from source other than \textit{GitHub} or actually including examples from e.g. a company with projects in different programming languages would also be of interest.

Further, an independent validation of these results with another toolchain or another code clone detector than \teamscale{} is also thinkable.

A more qualitative approach could also be undertaken. Here, one could analyze only specific projects in more detail, like e.g. logging frameworks which usually exist in nearly every programming language.
 
