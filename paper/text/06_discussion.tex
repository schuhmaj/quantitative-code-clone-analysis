% !TeX spellcheck = en_US
\section{Discussion}
\label{sec:discussion}

\autoref{sec:results} has shown that the in \autoref{sec:study_design} presented approach for quantitatively measuring clone coverage in different programming languages is capable of answering some of the asked \aclp{rq}. This section will discuss and explain the observed results and evaluate the used approach.

\subsection{Implications of the result}

%Can we infer that a simpler, less verbose, more modern programming language always leads to less code clones?

At the outset, the extracted data does not imply that a particular programming language, e.g., \texttt{Python}, which performed best, should be used for every project. 
However, the results show that specific languages, \texttt{Python}, \texttt{Kotlin}, and \texttt{Rust}, performed significantly better than \texttt{C/C++} or \texttt{Java} and, therefore, seem to have advantages over the others.
One reason for fewer clones could be a less verbose, more straightforward programming language design, as discussed in \autoref{sec:similiar_analyses}, yet this argument can be partially discarded since \texttt{Go} performs for projects bigger than $10^6$ \ac{sloc}, similarly to \texttt{Java} and \texttt{C/C++}, although \texttt{Go} has the smallest set of keywords - implying simplicity, as depicted in \autoref{tab:keyword_number}.

\begin{table}[tbh!]
	\centering
	\begin{tabular}{|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{1.5cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{1.5cm}|}
		\hline
		C/C++ 17 & Kotlin 1.4 & Rust 1.46 & Java 14 & C18 & Python 3.8 & Go 1.15 \\
		\hline
		84 & 79 & 53 & 51 & 44 & 35 & 25 \\
		\hline
	\end{tabular}
	\caption{Number of keywords for each examined programming language \cite{meyer2022keywords}}
	\label{tab:keyword_number}
\end{table}

Further, \autoref{sec:similiar_analyses} already introduced build systems as crucial for project success. Here might be another reason located. Simple to use package managers make importing existing solutions much more effortless, thereby preventing \textit{Reinventing the wheel}, a.k.a copying existing solutions. \texttt{Rust} and \texttt{Python} come with package managers \texttt{cargo} and \texttt{pip}, making the use of existing solutions much more manageable. In comparison, \texttt{C/C++} and \texttt{Java} rely on build systems like \texttt{CMake} and \texttt{Maven}, usually with a high learning curve. For example, to include a simple package/ library in \texttt{Python}, one must install and import it, whereas, in \texttt{CMake}, far more effort would be needed.

Lastly, one does not forget that, e.g., \texttt{Kotlin} and \texttt{Rust} improve \texttt{Java} and \texttt{C/C++}, respectively introducing null-safety and ownership. Thus these improvements avoid redundant, often repeated runtime checks like mentioned in \autoref{sec:reasons_for_code_clones} (reusing certain code structures).

Despite these reasons, the difference in mean clone coverage does not necessarily indicate that the programming language has flaws.
Older projects often have a greater (legacy) code base, which already can contain clones and makes it easy to copy and paste from there. 
However, \texttt{Rust}, \texttt{Kotlin}, and \texttt{Go} projects cannot be yet as old as projects in \texttt{C/C++} or \texttt{Java}. Consequently, the newer programming languages have some "time" advantage over the older ones, with projects having fewer developer changes and less legacy code.

In conclusion, we can finalize with the strong empirical suspect, but with no absolute certainty, that \texttt{Python}, \texttt{Kotlin}, and \texttt{Rust} are better designed to prevent code cloning than \texttt{C/C++}, \texttt{Java}, and \texttt{Go}, especially for larger projects with more extensive code bases.

 
\subsection{Threads to validity}

As the section above finalizes this work's conclusion, it is also required to include potential distortions.

First, the \textit{awesome lists} are different in size and contain different content for every programming language. Numerous contributors created them. Nonetheless, we have little information about why exactly something is on the list. So it is likely, that each list contains a certain bias. Additionally, the lists can also incorporate repositories containing only code snippets and similar utilities. The expressive analysis for more than $10^6$ \ac{sloc} should ensure that such projects are excluded, but a residual risk remains.

Directly related to this, the programming projects originate all from \textit{GitHub} and are publicly available. This circumstance is definitely a bias, since our study is not able to cover proprietary code nor big projects hosted on a different source.

The most considerable bias could be the evolution of programming languages. Writing modern \texttt{C++20} follows different guidelines than writing \texttt{C++98}. This behaves analogously to \texttt{Java} and \texttt{Python}. However, the study does not include when the projects were initially written and if they were refactored.

Lastly, $5224$ projects of only seven different programming languages were analyzed, which is, of course, only a tiny fraction at all.

\subsection{Future Work}

Directly related to the previous lessons of this section, future work could improve the solution by extending the scale of investigated projects and the concrete source. For example, a discarded approach for this work was the inclusion of projects from \textit{GitHub} with a certain amount of stars. The inclusion of projects from sources other than \textit{GitHub} or actually including examples from, e.g., a company with projects in different programming languages would also be of interest.

Further, independent validation of these results with another toolchain or another code clone detector than \teamscale{} is also thinkable.

A more qualitative approach could also be undertaken. Here, one could analyze only specific projects in more detail, like logging frameworks which usually exist in nearly every programming language and have similar functionality.
 
